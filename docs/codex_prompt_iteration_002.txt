You are continuing development of the app “glance”.

The application already:
- runs as a Photino desktop app
- starts an ASP.NET Core backend
- serves a Vue UI (via Vite dev server in development)
- persists tasks in SQLite
- supports multi-instance updates via /api/changes polling

DO NOT BREAK EXISTING FUNCTIONALITY.

==================================================
AUTHORITATIVE DOCUMENTS (DO NOT MODIFY)
==================================================

- docs/architecture.md
- docs/requirements.feature
- docs/api.md
- docs/schema.sql
- docs/migrations/*

If behavior is unclear, prefer the simplest interpretation that does not contradict these documents.

==================================================
GOAL: ITERATION 2
==================================================

Make task lists **actually editable** and usable, while still keeping
the editor deliberately minimal.

After this iteration, a user must be able to:
- create tasks by typing
- edit task titles inline
- edit task subcontent inline
- persist edits automatically
- see edits reflected in another running instance

==================================================
EDITOR SCOPE (IMPORTANT)
==================================================

This iteration introduces a **minimal editor**, NOT the final rich-text editor.

Requirements:
- Task title:
  - single-line editable input
  - saved on blur or debounce
- Task subcontent:
  - editable multiline text area OR minimal ProseMirror editor
  - plain text is acceptable for now
- Formatting, images, highlights, indentation rules:
  - DO NOT implement yet

The goal is correctness and persistence, not UX polish.

==================================================
DASHBOARD BEHAVIOR
==================================================

- Both “New tasks” and “Main tasks” lists must be editable.
- Each task renders as:
  - title input
  - subcontent editor below it
- Creating a task:
  - typing into an empty “New task” input creates a new task row
- Editing:
  - changes are autosaved (debounced, e.g. 500–1000 ms)
- Completion:
  - clicking a checkbox or button marks task complete/uncomplete
  - completed tasks update visually and persist

==================================================
PERSISTENCE RULES
==================================================

- All edits go through the backend API (no direct SQLite access from UI).
- Use existing endpoints:
  - POST /api/tasks
  - PUT /api/tasks/{id}
  - POST /api/tasks/{id}/complete
- Update `changes` table on every write.

==================================================
MULTI-INSTANCE REQUIREMENTS
==================================================

- When a task is edited in one instance:
  - the other instance reloads that task within ~1 second
- If the user is actively editing a task that changed externally:
  - reload content only if local editor is not dirty
  - otherwise, do nothing (last-write-wins is acceptable)

==================================================
NON-GOALS (DO NOT IMPLEMENT)
==================================================

- ProseMirror schema invariants
- formatting (bold/italic/highlight)
- images or paste handling
- recurrence logic
- history charts
- search highlighting
- category derivation beyond what already exists

==================================================
IMPLEMENTATION GUIDANCE
==================================================

Frontend:
- Prefer simple Vue components over abstraction.
- Each task component owns its edit state.
- Use debounce for autosave.
- Poll /api/changes and refresh affected tasks.

Backend:
- Validate title is single-line.
- Treat content as opaque text or JSON.
- Keep database transactions short.

==================================================
DELIVERABLES
==================================================

- Tasks can be created, edited, and completed via the UI.
- Changes persist across restarts.
- Changes propagate across two running instances.
- Provide brief notes on what was added in Iteration 2.

Proceed by upgrading the Dashboard UI first, then wiring persistence.
